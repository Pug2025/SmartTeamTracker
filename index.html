<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<link rel="manifest" href="manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Team Tracker – iPhone (v5.1.1)</title>
<style>
  :root{
    /* Theme: High Contrast / Split Brain */
    --bg:#000000;
    --panel:#111111;
    --ink:#ffffff;
    --muted:#888888;

    /* Zones */
    --zone-us:#0a1a2a;       /* Dark Blue background for 'Us' */
    --zone-them:#1f0a0a;     /* Dark Red background for 'Them' */
    --accent-us:#4da3ff;     /* Bright Blue */
    --accent-them:#ff453a;   /* Bright Red */
    --good:#32d74b;
    --warn:#ff9f0a;

    --radius:16px;
    --header-height:100px;
  }
  html,body{height:100%}
  body{
    margin:0;
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",Roboto,Helvetica,Arial,sans-serif;
    background:var(--bg);
    color:var(--ink);
    padding-bottom:80px; /* Space for FAB */
  }

  /* Basic utility / text classes */
  .inlineRow{
    display:flex;
    align-items:center;
    gap:8px;
  }
  .small{
    font-size:12px;
    color:var(--muted);
  }
  .banner{
    font-size:12px;
    padding:6px 10px;
    border-radius:10px;
    background:#1a1200;
    border:1px solid #444;
  }
  .card{
    background:#111;
    border:1px solid #333;
    border-radius:12px;
    padding:10px;
  }
  .btn{
    font-family:inherit;
  }

  /* ===== Sticky Header & Scoreboard ===== */
  .sticky-header{
    position:sticky;
    top:0;
    z-index:1000;
    background:rgba(10,10,10,0.95);
    backdrop-filter:blur(10px);
    border-bottom:1px solid #333;
    padding-bottom:10px;
  }
  .top-row{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:8px 14px;
  }
  .top-row h1{
    font-size:18px;
    margin:0;
    font-weight:700;
    letter-spacing:-0.5px;
  }

  .scoreboard-row{
    display:grid;
    grid-template-columns: 1fr auto 1fr;
    align-items:center;
    padding:0 14px 6px 14px;
    gap:12px;
  }
  .score-block{
    display:flex;
    flex-direction:column;
    border-radius:12px;
    padding:6px 10px;
    position:relative;
  }
  .score-block.us{
    background:var(--zone-us);
    border:1px solid #1a3a5a;
    align-items:flex-end;
  }
  .score-block.them{
    background:var(--zone-them);
    border:1px solid #5a1a1a;
    align-items:flex-start;
  }

  .score-label{
    font-size:11px;
    text-transform:uppercase;
    color:var(--muted);
    font-weight:700;
    letter-spacing:0.5px;
  }
  .score-val{
    font-size:32px;
    font-weight:800;
    line-height:1;
    margin-top:2px;
    transition: transform 0.1s;
  }
  .score-sub{
    margin-top:4px;
    font-size:12px;
    color:var(--muted);
    font-weight:700;
    letter-spacing:0.2px;
  }

  /* Pulse Animation for Score */
  @keyframes pulse-green {
    0% {color:#fff;}
    50% {color:var(--good); transform:scale(1.2);}
    100% {color:#fff;}
  }
  @keyframes pulse-red {
    0% {color:#fff;}
    50% {color:var(--accent-them); transform:scale(1.2);}
    100% {color:#fff;}
  }
  .pulse-good { animation: pulse-green 0.4s ease-out; }
  .pulse-bad { animation: pulse-red 0.4s ease-out; }

  /* Period Selector (Segmented) */
  .period-seg{
    display:flex;
    background:#1c1c1e;
    border-radius:10px;
    padding:3px;
    border:1px solid #333;
  }
  .p-opt{
    padding:6px 10px;
    font-size:13px;
    font-weight:700;
    border-radius:7px;
    color:var(--muted);
    cursor:pointer;
  }
  .p-opt.active{
    background:#444;
    color:#fff;
    box-shadow:0 2px 6px rgba(0,0,0,0.3);
  }

  .wrap{
    max-width:520px;
    margin:0 auto;
    padding:14px;
  }

  /* ===== Setup Panel (Collapsible) ===== */
  #setupContainer{ display:block; }
  #gameControls{ display:none; }
  .setup-card{
    background:var(--panel);
    border:1px solid #333;
    border-radius:var(--radius);
    padding:20px;
    margin-top:20px;
    text-align:center;
  }
  .setup-card h2{
    margin-top:0;
    font-size:18px;
  }
  .input-group{
    text-align:left;
    margin-bottom:12px;
  }
  label{
    display:block;
    font-size:12px;
    color:var(--muted);
    margin-bottom:6px;
  }
  input, select, textarea{
    width:100%;
    box-sizing:border-box;
    background:#000;
    border:1px solid #333;
    color:#fff;
    padding:12px;
    border-radius:10px;
    font-size:16px;
    outline:none;
  }
  .btn-start{
    width:100%;
    background:var(--accent-us);
    color:#000;
    border:none;
    padding:16px;
    font-size:18px;
    font-weight:800;
    border-radius:14px;
    margin-top:10px;
    cursor:pointer;
  }
  .btn-edit-setup{
    background:none;
    border:none;
    color:var(--muted);
    font-size:12px;
    text-decoration:underline;
    padding:0;
    margin:0;
    cursor:pointer;
  }

  /* ===== Split Brain Controls ===== */
  .split-grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
    margin-top:10px;
  }
  .col-zone{
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  /* Button Styling */
  .g-btn{
    -webkit-tap-highlight-color:transparent;
    border-radius:12px;
    border:1px solid;
    color:#fff;
    font-weight:700;
    font-size:15px;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    cursor:pointer;
    user-select:none;
    touch-action:manipulation;
    transition:transform 0.05s, opacity 0.1s, box-shadow 0.15s;
    box-shadow:none;
  }
  .g-btn:active{
    transform:scale(0.97);
    opacity:0.8;
  }
  .g-btn.primary{
    box-shadow:0 4px 10px rgba(0,0,0,0.4);
  }

  /* Sizes */
  .h-lg{
    height:85px;
    font-size:18px;
    font-weight:800;
  } /* Primary Action */
  .h-md{
    height:55px;
    font-size:14px;
  }

  /* Theme: THEM (Left/Red) */
  .theme-them .g-btn{
    background:var(--zone-them);
    border-color:#5a1a1a;
  }
  .theme-them .g-btn.primary{
    background:#3a0e0e;
    border-color:var(--accent-them);
  }
  .theme-them .g-btn.ctx{
    background:#140707;
    border-color:#5a1a1a;
    border-style:dashed;
    font-size:12px;
  }

  /* Theme: US (Right/Blue) */
  .theme-us .g-btn{
    background:var(--zone-us);
    border-color:#1a3a5a;
  }
  .theme-us .g-btn.primary{
    background:#0f2b45;
    border-color:var(--accent-us);
    box-shadow:0 4px 10px rgba(0,0,0,0.4);
  }
  .theme-us .g-btn.positive{
    border-color:var(--good);
    color:var(--good);
  } /* Smother/Saves */
  .theme-us .g-btn.ctx{
    background:#071421;
    border-color:#1a3a5a;
    border-style:dashed;
    font-size:12px;
  }

  /* Grid dividers/labels */
  .col-label{
    font-size:10px;
    text-transform:uppercase;
    letter-spacing:1px;
    text-align:center;
    margin-bottom:4px;
    opacity:0.5;
  }

  .context-row{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:8px;
  }

  .def-context-label{
    font-size:10px;
    text-transform:uppercase;
    letter-spacing:0.8px;
    opacity:0.6;
    margin-top:4px;
  }

  /* ===== Next Period Full-Width Bar ===== */
  .next-period-wrap{
    margin-top:14px;
  }
  .next-period-btn{
    width:100%;
    background:#222;
    border-color:#444;
    font-size:14px;
    border-radius:999px;
  }

  /* ===== Floating Undo (FAB) ===== */
  .fab-undo{
    position:fixed;
    bottom:24px;
    right:24px;
    width:64px;
    height:64px;
    border-radius:50%;
    background:#222;
    border:2px solid #444;
    color:#fff;
    font-size:12px;
    font-weight:700;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow:0 8px 24px rgba(0,0,0,0.5);
    z-index:2000;
    cursor:pointer;
  }
  .fab-undo:active{
    transform:scale(0.95);
    background:#333;
  }

  /* ===== Live Dashboard ===== */
  .dash{
    margin-top:14px;
    background:#0b0b0b;
    border:1px solid #222;
    border-radius:14px;
    padding:10px;
  }
  .dashTop{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:6px 4px 10px 4px;
    border-bottom:1px solid #1f1f1f;
    margin-bottom:10px;
  }
  .dashTop .t{
    font-weight:800;
    letter-spacing:-0.2px;
  }
  .dashGrid{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:10px;
  }
  .dashTile{
    background:#0f0f0f;
    border:1px solid #242424;
    border-radius:14px;
    padding:10px;
    min-height:70px;
    display:flex;
    flex-direction:column;
    justify-content:space-between;
  }
  .dashTile .k{
    font-size:12px;
    color:#9aa6b2;
    font-weight:700;
  }
  .dashTile .v{
    font-size:26px;
    font-weight:900;
    letter-spacing:-0.5px;
  }
  .dashTile .s{
    font-size:12px;
    color:var(--muted);
    font-weight:700;
  }

  /* Period tiles: tighter + clearer hierarchy than KPI tiles */
  .periodGrid .dashTile{
    min-height:60px;
    padding:10px 12px;
  }
  .periodGrid .dashTile .k{
    font-size:11px;
    opacity:0.85;
  }
  .periodGrid .dashTile .v{
    font-size:22px;
    font-weight:900;
    letter-spacing:-0.3px;
    line-height:1.05;
  }
  .periodGrid .dashTile .s{
    font-size:11px;
    opacity:0.85;
  }

  .dashWide{
    grid-column:1/-1;
    display:flex;
    justify-content:space-between;
    gap:10px;
    align-items:center;
  }
  .ringsRow{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
    margin-bottom:10px;
  }
  .ringCard{
    background:#0f0f0f;
    border:1px solid #242424;
    border-radius:14px;
    padding:10px;
    text-align:center;
  }

  /* ===== Stats & Log ===== */
  .log-container{
    margin-top:16px;
    background:#080808;
    border:1px solid #222;
    border-radius:12px;
    height:160px;
    overflow-y:auto;
    padding:8px;
  }
  .log-item{
    font-size:12px;
    padding:4px 0;
    border-bottom:1px dashed #222;
    color:#ccc;
    display:flex;
    justify-content:space-between;
    gap:8px;
    align-items:center;
  }
  .log-main{
    flex:1;
  }
  .log-meta{
    opacity:0.7;
    margin-right:4px;
  }
  .badge{
    display:inline-block;
    padding:2px 6px;
    border-radius:8px;
    border:1px solid #333;
    font-size:10px;
    margin-left:4px;
  }
  .badge-tag{
    border-color:var(--accent-us);
    color:var(--accent-us);
    cursor:pointer;
  }

  /* ===== Summary Panels / Dialogs (reused) ===== */
  .panel{
    background:var(--panel);
    border-radius:var(--radius);
    padding:12px;
    margin-top:10px;
    border:1px solid #333;
  }
  .hidden{ display:none!important; }
  .modal{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.8);
    z-index:9999;
    display:none;
    align-items:center;
    justify-content:center;
    padding:16px;
  }
  .modal .box{
    background:#111;
    border:1px solid #333;
    border-radius:12px;
    width:100%;
    max-width:420px;
    padding:16px;
  }

  /* Rings */
  .scoreRing{
    position:relative;
    width:80px;
    height:80px;
    margin:0 auto;
  }
  .ringSvg{
    transform:rotate(-90deg);
    width:100%;
    height:100%;
  }
  .ringBg{
    fill:none;
    stroke:#333;
    stroke-width:6;
  }
  .ringFg{
    fill:none;
    stroke:var(--accent-us);
    stroke-width:6;
    stroke-linecap:round;
    transition:stroke-dashoffset 0.5s, stroke 0.2s;
    stroke-dasharray:220;
    stroke-dashoffset:220;
  }
  .scoreRing .val{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:24px;
    font-weight:800;
  }

  .pill{
    font-size:10px;
    padding:3px 8px;
    border-radius:10px;
    background:#222;
    border:1px solid #333;
    color:#888;
  }
  .pill.good{
    color:var(--good);
    border-color:var(--good);
  }
  .pill.warn{
    color:var(--warn);
    border-color:var(--warn);
  }
  .pill.bad{
    color:var(--accent-them);
    border-color:var(--accent-them);
  }

  .ai-actions{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin-top:10px;
  }
  .btn.ai{
    padding:10px;
    background:#1a1a1a;
    border:1px solid #333;
    color:#ccc;
    border-radius:8px;
    flex:1;
  }

  /* Common utils */
  .rowbtn{
    display:flex;
    gap:10px;
    margin-top:10px;
    justify-content:flex-end;
    flex-wrap:wrap;
  }
  .btn-std{
    padding:10px 16px;
    background:#222;
    border:1px solid #444;
    color:#fff;
    border-radius:8px;
    cursor:pointer;
  }

  /* Picker Grid */
  .pickerGrid{
    display:grid;
    grid-template-columns:repeat(4,1fr);
    gap:8px;
    margin-top:10px;
  }
  .pickerBtn{
    background:#222;
    border:1px solid #333;
    padding:12px;
    border-radius:8px;
    text-align:center;
    font-weight:700;
    cursor:pointer;
  }
  .pickerBtn.selected{
    background:#0f2b45;
    border-color:var(--accent-us);
  }

  /* Tables in summary */
  table{
    width:100%;
    border-collapse:collapse;
    margin-top:6px;
    font-size:12px;
  }
  th,td{
    border:1px solid #333;
    padding:6px 6px;
    text-align:center;
  }
  th{
    background:#181818;
  }

  /* Undo Modal */
  .undoRow{
    padding:6px 4px;
    border-bottom:1px solid #222;
    cursor:pointer;
    font-size:12px;
  }

  /* Toast */
  .toast{
    position:fixed;
    left:50%;
    bottom:12px;
    transform:translateX(-50%);
    background:#111;
    border:1px solid #333;
    border-radius:20px;
    padding:8px 14px;
    font-size:12px;
    display:none;
    z-index:3000;
  }
</style>
</head>
<body>

<!-- Sticky Header -->
<header class="sticky-header">
  <div class="top-row">
    <div class="inlineRow">
      <h1>Team Tracker</h1>
      <div class="pill" id="verPill">v—</div>
      <div class="pill" id="cloudStatus">Cloud: —</div>
    </div>
    <div class="inlineRow">
      <button class="btn-edit-setup" id="btnEditSetup" style="display:none;">Edit Info</button>
      <button class="btn-std" id="btnRoster" style="font-size:11px; padding:6px 10px;">Roster</button>
    </div>
  </div>

  <div class="scoreboard-row">
    <!-- THEM LEFT, US RIGHT -->
    <div class="score-block them">
      <span class="score-label">THEM</span>
      <span id="liveGA" class="score-val">0</span>
      <div class="score-sub" id="liveSA_sub">SA: 0</div>
    </div>

    <div class="period-seg" id="periodChips">
      <div class="p-opt active" data-p="1">1</div>
      <div class="p-opt" data-p="2">2</div>
      <div class="p-opt" data-p="3">3</div>
      <div class="p-opt" data-p="4">OT</div>
    </div>

    <div class="score-block us">
      <span class="score-label">US</span>
      <span id="liveGF" class="score-val">0</span>
      <div class="score-sub" id="liveSF_sub">SF: 0</div>
    </div>
  </div>
</header>

<div class="wrap">

  <!-- Setup Panel (Initially Visible) -->
  <div id="setupContainer">
    <div class="setup-card">
      <h2>Game Setup</h2>
      <div class="input-group">
        <label>Opponent Name</label>
        <input id="opponent" placeholder="e.g. Napanee Stars" autocomplete="off">
      </div>
      <div class="input-group">
        <label>Level</label>
        <select id="level">
          <option>U9</option>
          <option selected>U11</option>
          <option>U13</option>
          <option>U15</option>
          <option>U18</option>
          <option>Other</option>
        </select>
      </div>
      <div class="input-group">
        <label>Date</label>
        <input id="date" type="date">
      </div>
      <div id="resumeBanner" class="banner hidden" style="font-size:12px; color:var(--warn); margin-bottom:10px;">Resumed saved game.</div>
      <button id="btnStartGame" class="btn-start">Start Game</button>
    </div>
  </div>

  <!-- Game Controls (Initially Hidden) -->
  <div id="gameControls">

    <div class="split-grid">

      <!-- LEFT COLUMN: THEM / BAD (Red) -->
      <div class="col-zone theme-them">
        <div class="col-label">Them</div>
        <!-- Primary -->
        <div class="g-btn primary h-lg" id="btnShot">Shot Against</div>
        <div class="g-btn primary h-lg" id="btnGoal">Goal Against</div>
        <!-- Secondary -->
        <div class="g-btn h-md" id="btnSoftGoal">Soft Goal</div>
        <div class="g-btn h-md" id="btnBadRebound">Bad Rebound</div>

        <div class="def-context-label">Defensive Context</div>
        <div class="context-row">
          <div class="g-btn ctx h-md" id="btnBreakaway">Breakaway Ag</div>
          <div class="g-btn ctx h-md" id="btnDZTurnover">DZ Turnover</div>
        </div>
      </div>

      <!-- RIGHT COLUMN: US / GOOD (Blue) -->
      <div class="col-zone theme-us">
        <div class="col-label">Us</div>
        <!-- Primary -->
        <div class="g-btn primary h-lg" id="btnForShot">Shot For</div>
        <div class="g-btn primary h-lg" id="btnForGoal">Goal For</div>
        <!-- Goalies -->
        <div class="g-btn positive h-md" id="btnSmother">Smother</div>
        <div class="g-btn positive h-md" id="btnBigSave">Big Save</div>

        <div class="def-context-label">Offensive Context</div>
        <div class="context-row">
          <div class="g-btn ctx h-md" id="btnOddManRushFor">Odd Man Rush</div>
          <div class="g-btn ctx h-md" id="btnBreakawayFor">Breakaway</div>
        </div>
      </div>

    </div>

    <!-- Next Period: global full-width control -->
    <div class="next-period-wrap">
      <div class="g-btn next-period-btn" id="btnNextPeriod">Next Period</div>
    </div>

    <!-- Live Dashboard -->
    <div class="dash">
      <div class="dashTop">
        <div class="t">Scoreboard</div>
        <div class="small" id="dashLine">GF 0 • GA 0 • SF 0 • SA 0</div>
      </div>

      <div class="ringsRow">
        <div class="ringCard">
          <div class="small" style="margin-bottom:6px;">Goalie Score</div>
          <div class="scoreRing">
            <svg viewBox="0 0 80 80" class="ringSvg">
              <circle class="ringBg" cx="40" cy="40" r="35"></circle>
              <circle class="ringFg" id="gsArc" cx="40" cy="40" r="35"></circle>
            </svg>
            <div class="val" id="goalieScoreNum">—</div>
          </div>
        </div>
        <div class="ringCard">
          <div class="small" style="margin-bottom:6px;">Team Score</div>
          <div class="scoreRing">
            <svg viewBox="0 0 80 80" class="ringSvg">
              <circle class="ringBg" cx="40" cy="40" r="35"></circle>
              <circle class="ringFg" id="tsArc" cx="40" cy="40" r="35"></circle>
            </svg>
            <div class="val" id="teamScoreNum">—</div>
          </div>
        </div>
      </div>

      <div class="dashGrid">
        <div class="dashTile"><div class="k">Saves</div><div class="v" id="savesVal">0</div><div class="s" id="svVal">SV% —</div></div>
        <div class="dashTile"><div class="k">Smothers</div><div class="v" id="smothersVal">0</div><div class="s">Tracked</div></div>
        <div class="dashTile"><div class="k">Bad Rebounds</div><div class="v" id="badRebVal">0</div><div class="s">Tracked</div></div>

        <div class="dashTile"><div class="k">Big Saves</div><div class="v" id="bigSavesVal">0</div><div class="s">Tracked</div></div>
        <div class="dashTile"><div class="k">Our Shooting %</div><div class="v" id="shootPctVal">—</div><div class="s">GF / SF</div></div>
        <div class="dashTile"><div class="k">Shot Share</div><div class="v" id="shotShareVal">—</div><div class="s">SF / (SF+SA)</div></div>

        <div class="dashTile"><div class="k">Breakaways Ag</div><div class="v" id="baAgVal">0</div><div class="s">Tracked</div></div>
        <div class="dashTile"><div class="k">D-Zone TO</div><div class="v" id="dzVal">0</div><div class="s">Tracked</div></div>
        <div class="dashTile"><div class="k">Soft Goals</div><div class="v" id="softVal">0</div><div class="s">Tracked</div></div>

        <div class="dashTile"><div class="k">Breakaways For</div><div class="v" id="baForVal">0</div><div class="s">Offensive ctx</div></div>
        <div class="dashTile"><div class="k">Odd Man Rush For</div><div class="v" id="omrForVal">0</div><div class="s">Offensive ctx</div></div>
        <div class="dashTile"><div class="k">Good Rebounds</div><div class="v" id="goodRebVal">0</div><div class="s">Auto credit</div></div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="small" style="margin-bottom:8px;">By Period</div>
        <div class="dashGrid periodGrid" style="grid-template-columns:repeat(2,1fr);">
          <div class="dashTile"><div class="k">P1</div><div class="v" id="p1Line">—</div><div class="s">—</div></div>
          <div class="dashTile"><div class="k">P2</div><div class="v" id="p2Line">—</div><div class="s">—</div></div>
          <div class="dashTile"><div class="k">P3</div><div class="v" id="p3Line">—</div><div class="s">—</div></div>
          <div class="dashTile"><div class="k">OT</div><div class="v" id="p4Line">—</div><div class="s">—</div></div>
        </div>
      </div>
    </div>

    <!-- Log -->
    <div class="log-container" id="log"></div>

    <div class="rowbtn" style="justify-content:center; margin-top:20px;">
      <button class="btn-std" id="btnEnd" style="border-color:var(--good); color:var(--good);">End Game &amp; Score</button>
      <button class="btn-std" id="btnReset">New Game</button>
    </div>

  </div> <!-- End Game Controls -->

  <!-- Summary Panel -->
  <section class="panel hidden" id="summaryPanel">
    <h2 style="margin:0 0 10px 0; font-size:16px;">Game Summary</h2>
    <div id="summaryTitle" class="small" style="margin-bottom:12px; color:#aaa;"></div>

    <div style="display:flex; justify-content:center; gap:20px; margin-bottom:20px;">
      <div style="text-align:center;">
        <div class="scoreRing" id="gsRing">
          <svg viewBox="0 0 80 80" class="ringSvg">
            <circle class="ringBg" cx="40" cy="40" r="35"></circle>
            <circle class="ringFg" id="gsArcSum" cx="40" cy="40" r="35"></circle>
          </svg>
          <div class="val" id="goalieScoreNumSum">—</div>
        </div>
        <div class="small" style="margin-top:6px;">Goalie Score</div>
      </div>
      <div style="text-align:center;">
        <div class="scoreRing" id="tsRing">
          <svg viewBox="0 0 80 80" class="ringSvg">
            <circle class="ringBg" cx="40" cy="40" r="35"></circle>
            <circle class="ringFg" id="tsArcSum" cx="40" cy="40" r="35"></circle>
          </svg>
          <div class="val" id="teamScoreNumSum">—</div>
        </div>
        <div class="small" style="margin-top:6px;">Team Score</div>
      </div>
    </div>

    <div class="card" style="margin-top:10px;">
      <h3 style="margin:0 0 6px 0;">All Stats</h3>
      <div id="allStatsGrid"></div>
    </div>

    <details class="card" style="margin-top:10px;">
      <summary style="cursor:pointer; font-weight:800;">Scoring audit (expand)</summary>

      <div style="margin-top:10px;">
        <div class="small" style="font-weight:800; margin-bottom:4px;">Strength</div>
        <div class="small" id="strengthBreakdown"></div>
      </div>

      <div style="margin-top:10px;">
        <div class="small" style="font-weight:800; margin-bottom:4px;">Goalie</div>
        <div class="small" id="scoreBreakdown"></div>
      </div>

      <div style="margin-top:10px;">
        <div class="small" style="font-weight:800; margin-bottom:4px;">Team</div>
        <div class="small" id="teamBreakdown"></div>
      </div>
    </details>

    <div id="summaryTableWrap" style="margin-top:15px;"></div>
    <div id="pmTableWrap" style="margin-top:15px;"></div>
    <div id="gaDetailWrap" style="margin-top:15px;"></div>

    <div class="ai-actions">
      <button class="btn ai" id="btnAIPractice">Practice Plan</button>
      <button class="btn ai" id="btnAIGoalieReport">Goalie Report</button>
      <button class="btn ai" id="btnAIFocus">Next Game Focus</button>
    </div>

    <!-- AI Results Cards -->
    <div class="card" id="aiPracticeCard" style="margin-top:10px;display:none;">
      <h3 style="margin:0 0 6px 0;">AI Practice Plan</h3><div class="small" id="aiPracticeBody"></div>
    </div>
    <div class="card" id="aiGoalieCard" style="margin-top:10px;display:none;">
      <h3 style="margin:0 0 6px 0;">AI Goalie Report</h3><div class="small" id="aiGoalieBody"></div>
    </div>
    <div class="card" id="aiFocusCard" style="margin-top:10px;display:none;">
      <h3 style="margin:0 0 6px 0;">AI Next Game Focus</h3><div class="small" id="aiFocusBody"></div>
    </div>

    <div class="rowbtn" style="margin-top:20px; justify-content:center;">
      <button class="btn-std" id="btnExportGameCSV">Export CSV</button>
      <button class="btn-std" id="btnCopySummary">Copy Text</button>
    </div>
  </section>

</div>

<!-- Floating Undo Button -->
<div id="btnUndo" class="fab-undo">UNDO</div>

<!-- MODALS -->
<!-- Roster modal -->
<div class="modal" id="rosterModal"><div class="box">
  <div class="small" style="margin-bottom:6px;">Roster (one # per line)</div>
  <textarea id="rosterArea" style="width:100%; height:150px; background:#000; border:1px solid #333; color:#fff; padding:8px;"></textarea>
  <div class="rowbtn">
    <button class="btn-std" id="btnRosterSave">Save</button>
    <button class="btn-std" id="btnRosterClose" style="border-color:#444;">Close</button>
  </div>
</div></div>

<!-- Player picker -->
<div class="modal" id="pickerModal"><div class="box">
  <div class="small" style="margin-bottom:8px;" id="pickerTitle">Select Player</div>
  <div class="pickerGrid" id="pickerGrid"></div>
  <div style="display:flex; gap:8px; margin-top:12px;">
    <input id="pickerInput" placeholder="#" type="tel" style="flex:1;">
    <button class="btn-std" id="pickerAdd">Use</button>
  </div>
  <div class="rowbtn" style="justify-content:space-between;">
    <button class="btn-std" id="pickerNone" style="display:none;">No Assist</button>
    <div style="display:flex; gap:8px;">
      <button class="btn-std" id="pickerUnknown">Unknown</button>
      <button class="btn-std" id="pickerCancel">Cancel</button>
    </div>
  </div>
</div></div>

<!-- GA Context -->
<div class="modal" id="gaOverlay"><div class="box">
  <div class="small" style="margin-bottom:8px;">Goal Against Context</div>
  <div class="pickerGrid" id="gaGrid" style="grid-template-columns:1fr 1fr;"></div>
  <div class="rowbtn">
    <button class="btn-std" id="gaSkip">Tag Later</button>
  </div>
</div></div>

<!-- Multi Picker -->
<div class="modal" id="onIceModal"><div class="box">
  <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
    <span class="small" id="onIceTitle">On Ice</span>
    <span class="small"><span id="onIceCount">0</span>/<span id="onIceMax">5</span></span>
  </div>
  <div class="pickerGrid" id="onIceGrid"></div>
    <div style="display:flex; gap:8px; margin-top:12px;">
    <input id="onIceInput" placeholder="#" type="tel" style="flex:1;">
    <button class="btn-std" id="onIceAdd">Use</button>
  </div>

  <div class="rowbtn" style="justify-content:space-between; margin-top:12px;">
    <button class="btn-std" id="onIceUnknownPlus">Unk +</button>
    <button class="btn-std" id="onIceUnknownMinus">Unk -</button>
    <button class="btn-std" id="onIceClear">Clear</button>
  </div>
  <div class="rowbtn">
    <button class="btn-std" id="onIceUse" style="border-color:var(--good); color:var(--good);">Use</button>
    <button class="btn-std" id="onIceCancel">Skip</button>
  </div>
  <div class="small" id="onIceUnknownBadge" style="text-align:center; margin-top:6px; opacity:0.5;"></div>
</div></div>

<!-- Strength -->
<div class="modal" id="strengthModal"><div class="box">
  <div class="small" style="margin-bottom:8px;" id="strengthTitle">Situation</div>
  <div class="pickerGrid" style="grid-template-columns:1fr;">
    <div class="pickerBtn" data-strength="EV">Even Strength (EV)</div>
    <div class="pickerBtn" data-strength="PP">Power Play (PP)</div>
    <div class="pickerBtn" data-strength="SH">Short Handed (SH)</div>
  </div>
  <div class="rowbtn"><button class="btn-std" id="strengthSkip">Skip</button></div>
</div></div>

<!-- Copy -->
<div class="modal" id="copyModal"><div class="box">
  <div class="small">Summary Text</div>
  <textarea id="copyArea" style="width:100%; height:200px; background:#000; color:#fff; margin-top:8px;"></textarea>
  <div class="rowbtn">
    <button class="btn-std" id="btnCopySelect">Select All</button>
    <button class="btn-std" id="btnCopyClose">Close</button>
  </div>
</div></div>

<!-- Undo List -->
<div class="modal" id="undoModal"><div class="box">
  <div class="small">Undo Event</div>
  <div class="undoList" id="undoList" style="max-height:250px; overflow:auto; margin-top:8px;"></div>
  <div class="rowbtn"><button class="btn-std" id="undoClose">Cancel</button></div>
</div></div>

<div class="toast" id="toast">Removed. <button id="toastRestore" style="background:none; border:none; color:var(--accent-us); font-weight:700;">Restore</button></div>

<!-- Debug (Hidden by default in UI but kept for ref) -->
<div id="debugWrap" style="display:none;">
  <div id="debugGoalieLine"></div><div id="debugTeamLine"></div>
</div>

<script>
/* ===== App Version ===== */
const APP_VERSION = '5.1.1';

if ('serviceWorker' in navigator) {
  window.addEventListener('load', ()=>navigator.serviceWorker.register('service-worker.js?v=5111'));
}

/* ===== IndexedDB KV helper ===== */
const idbKV = (() => {
  let dbp;
  function db(){
    if (dbp) return dbp;
    dbp = new Promise((resolve,reject)=>{
      const open = indexedDB.open('team-tracker-db',1);
      open.onupgradeneeded = () => open.result.createObjectStore('kvs');
      open.onerror = () => reject(open.error);
      open.onsuccess = () => resolve(open.result);
    });
    return dbp;
  }
  async function get(key){
    const d = await db();
    return new Promise((res,rej)=>{
      const r = d.transaction('kvs','readonly').objectStore('kvs').get(key);
      r.onsuccess = () => res(r.result);
      r.onerror = () => rej(r.error);
    });
  }
  async function set(key,val){
    const d = await db();
    return new Promise((res,rej)=>{
      const w = d.transaction('kvs','readwrite').objectStore('kvs').put(val,key);
      w.onsuccess = () => res();
      w.onerror = () => rej(w.error);
    });
  }
  return {get,set};
})();

const $ = id => document.getElementById(id);
const SAVE_KEY = 'team-tracker-state';
const ROSTER_KEY = 'team-tracker-roster';
const LAST_SAVED_KEY = 'team-tracker-last-saved-gameId';

/* ===== State ===== */
const state = {
  opponent:'',
  level:'U11',
  date:null,
  period:1,
  startedAt:new Date().toISOString(),
  gameId:Math.random().toString(36).slice(2),
  events:[],
  countsA:{shots:0, goals:0, softGoals:0, smothers:0, badRebounds:0, bigSaves:0},
  countsF:{shots:0, goals:0},
  team:{
    breakawaysAgainst:0,
    dzTurnovers:0,
    breakawaysFor:0,
    oddManRushFor:0
  },
  roster:[],
  lastEventId:0
};

let per = {1:initP(),2:initP(),3:initP(),4:initP()};
function initP(){
  return {
    A_shots:0, A_goals:0, A_smothers:0, A_badRebounds:0, A_bigSaves:0,
    F_shots:0, F_goals:0,
    BA:0, DZ:0,
    BF:0, OMRF:0
  };
}

/* ===== UI Logic for Start/Setup ===== */
function toggleSetup(showSetup){
  if(showSetup){
    $('setupContainer').style.display='block';
    $('gameControls').style.display='none';
    $('btnEditSetup').style.display='none';
    $('btnUndo').style.display='none';
  } else {
    $('setupContainer').style.display='none';
    $('gameControls').style.display='block';
    $('btnEditSetup').style.display='block';
    $('btnUndo').style.display='flex';
  }
}
$('btnStartGame').addEventListener('click', ()=>{
  // Ensure state has the displayed date even if user never touched the field
  if(!state.date){
    const v = $('date').value;
    if(v) state.date = v;
  }
  toggleSetup(false);
  vibrate(10);
});
$('btnEditSetup').addEventListener('click', ()=>{ toggleSetup(true); });

/* ===== Cloud status helper ===== */
function setCloudStatus(text, tone){
  const el = $('cloudStatus');
  if(!el) return;
  el.textContent = text;
  el.classList.remove('good','warn','bad');
  if(tone) el.classList.add(tone);
}
function refreshCloudStatus(){
  try{
    const last = localStorage.getItem(LAST_SAVED_KEY);
    if(last && last === state.gameId){
      setCloudStatus('Cloud: Saved','good');
    } else {
      // default to connectivity status (set by ping)
      // no-op here; pingCloud will set it
    }
  }catch(_){}
}

/* Make cloud pill useful: ping /api/ping to show online/offline */
let lastCloudPingAt = 0;
async function pingCloud(){
  // If a "Saved" for this game is showing, keep it (don’t overwrite with OK).
  const el = $('cloudStatus');
  if(el && /Cloud:\s*Saved/i.test(el.textContent)) return;

  try{
    setCloudStatus('Cloud: Checking…','warn');
    const ctrl = new AbortController();
    const to = setTimeout(()=>ctrl.abort(), 2500);

    const res = await fetch('/api/ping', { cache:'no-store', signal: ctrl.signal });
    clearTimeout(to);

    if(res.ok){
      setCloudStatus('Cloud: OK','good');
    } else {
      setCloudStatus('Cloud: Offline','bad');
    }
  }catch(_){
    setCloudStatus('Cloud: Offline','bad');
  } finally {
    lastCloudPingAt = Date.now();
  }
}

/* ===== Persistence ===== */
async function persistStorage(){
  try{
    if(navigator.storage && navigator.storage.persist){
      await navigator.storage.persist();
    }
  }catch(_){}
}
async function save(){
  try{
    const json = JSON.stringify(state);
    localStorage.setItem(SAVE_KEY,json);
    await idbKV.set(SAVE_KEY,json);
  }catch(_){}
}
async function load(){
  try{
    const v = await idbKV.get(SAVE_KEY);
    if(v) return JSON.parse(v);
  }catch(_){}
  try{
    const v = localStorage.getItem(SAVE_KEY);
    if(v) return JSON.parse(v);
  }catch(_){}
  return null;
}

/* Autosave & lifecycle saves (crash safety) */
setInterval(()=>save(), 4000);
window.addEventListener('pagehide', ()=>save());
document.addEventListener('visibilitychange', ()=>{
  if(document.visibilityState === 'hidden') save();
});

/* Periodic cloud ping (lightweight) */
setInterval(()=>{
  // ping more often during a live game; otherwise just leave whatever state is shown
  const live = (state.events && state.events.length>0) || ($('gameControls') && $('gameControls').style.display==='block');
  if(!live) return;
  if(Date.now() - lastCloudPingAt < 30000) return;
  pingCloud();
}, 5000);

/* ===== Helpers ===== */
function vibrate(ms=20){ if(navigator.vibrate) navigator.vibrate(ms); }

function highlightPeriod(){
  [...$('periodChips').children].forEach(ch=>{
    const p = Number(ch.dataset.p);
    ch.classList.toggle('active', p===state.period);
  });
}

function fmtTime(iso){
  const d=new Date(iso);
  return `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function isNumStr(x){ return typeof x==='string' && /^\d+$/.test(x.trim()); }
function sortRoster(arr){
  // numeric first, then alpha; stable-ish
  return [...arr].sort((a,b)=>{
    const an = isNumStr(String(a)) ? Number(a) : null;
    const bn = isNumStr(String(b)) ? Number(b) : null;
    if(an!==null && bn!==null) return an-bn;
    if(an!==null) return -1;
    if(bn!==null) return 1;
    return String(a).localeCompare(String(b));
  });
}
function ensureRosterNumber(num){
  const n = String(num||'').trim();
  if(!isNumStr(n)) return;
  const roster = new Set((state.roster||[]).map(x=>String(x).trim()).filter(Boolean));
  if(!roster.has(n)){
    roster.add(n);
    state.roster = sortRoster([...roster]);
    try{ localStorage.setItem(ROSTER_KEY, JSON.stringify(state.roster)); }catch(_){}
    save();
  }
}

/* ===== Event accounting ===== */
function bump(type, period){
  const p = per[period] || per[4];

  if(type==='shot'){
    state.countsA.shots++; p.A_shots++;
  }else if(type==='goal'){
    state.countsA.shots++; state.countsA.goals++;
    p.A_shots++; p.A_goals++;
  }else if(type==='soft_goal'){
    state.countsA.shots++; state.countsA.goals++; state.countsA.softGoals++;
    p.A_shots++; p.A_goals++;
  }else if(type==='smother'){
    state.countsA.smothers++; p.A_smothers++;
  }else if(type==='bad_rebound'){
    state.countsA.shots++; state.countsA.badRebounds++;
    p.A_shots++; p.A_badRebounds++;
  }else if(type==='big_save'){
    state.countsA.bigSaves++; state.countsA.shots++;
    p.A_bigSaves++; p.A_shots++;
  }else if(type==='for_shot'){
    state.countsF.shots++; p.F_shots++;
  }else if(type==='for_goal'){
    state.countsF.shots++; state.countsF.goals++;
    p.F_shots++; p.F_goals++;
  }else if(type==='breakaway_against'){
    state.team.breakawaysAgainst++; p.BA++;
  }else if(type==='dz_turnover'){
    state.team.dzTurnovers++; p.DZ++;
  }else if(type==='breakaway_for'){
    state.team.breakawaysFor++; p.BF++;
  }else if(type==='odd_man_rush_for'){
    state.team.oddManRushFor++; p.OMRF++;
  }
}

function rebuildFromEvents(){
  per = {1:initP(),2:initP(),3:initP(),4:initP()};
  state.countsA = {shots:0, goals:0, softGoals:0, smothers:0, badRebounds:0, bigSaves:0};
  state.countsF = {shots:0, goals:0};
  state.team = {breakawaysAgainst:0, dzTurnovers:0, breakawaysFor:0, oddManRushFor:0};

  for(const ev of state.events){
    bump(ev.type, ev.period);
  }
}

const pendingGood = new Map();
function scheduleGoodReboundCredit(id){
  if(pendingGood.has(id)) clearTimeout(pendingGood.get(id));
  const to = setTimeout(()=>{
    const ev = state.events.find(e=>e.id===id);
    if(ev && !ev.goodRebound){
      ev.goodRebound = true;
      save();
      renderAll();
    }
    pendingGood.delete(id);
  }, 4000);
  pendingGood.set(id, to);
}
function cancelRecentGoodCredit(){
  const ids = [...pendingGood.keys()];
  if(!ids.length) return;
  const lastId = ids[ids.length-1];
  clearTimeout(pendingGood.get(lastId));
  pendingGood.delete(lastId);
}
function clearGoodPendingFor(id){
  if(!pendingGood.has(id)) return;
  clearTimeout(pendingGood.get(id));
  pendingGood.delete(id);
}

/* Offensive breakaway timing */
let lastBreakawayForTap = 0;

function wasRecentEvent(type, seconds){
  const now = Date.now();
  const ms = seconds * 1000;

  for(let i = state.events.length - 1; i >= 0; i--){
    const ev = state.events[i];
    if(ev.type !== type) continue;
    const t = new Date(ev.tISO).getTime();
    return (now - t) <= ms;
  }
  return false;
}

function addEvent(type, meta={}){
  const ev = {
    id: ++state.lastEventId,
    type,
    tISO:new Date().toISOString(),
    period: state.period,
    ...meta
  };

  // If a follow-up outcome happens, cancel the pending "good rebound" credit
  // (shot → smother means no rebound; shot → bad rebound means rebound was bad; goal ends the sequence)
  if(type === 'smother' || type === 'bad_rebound' || type === 'goal' || type === 'soft_goal'){
    cancelRecentGoodCredit();
  }

  const isGoalAgainst = (type === 'goal' || type === 'soft_goal');
  const isGoalFor = (type === 'for_goal');

  state.events.push(ev);
  bump(type, state.period);

  // Tag Goals For context (Breakaway / Odd Man Rush / Other)
  if(isGoalFor){
    tagGFCause(ev);
  }

  // Always tag GA causes first (BA/DZ/BR can all apply)
  if(isGoalAgainst){
    tagGACause(ev);

    // auto-context shortcuts:
    // - Pure breakaway goal: auto-set Breakaway and skip modal
    // - Pure rebound goal (bad rebound within 5s, no BA/DZ): auto-set Rebound and skip modal
    const pureBreakaway = !!ev.ga_ba && !ev.ga_dz && !ev.ga_br;
    const pureRebound = !!ev.ga_br && !ev.ga_ba && !ev.ga_dz;

    if(pureBreakaway){
      ev.ga_ctx = 'Breakaway';
      ev.needsContext = false;
      save();
    } else if(pureRebound){
      ev.ga_ctx = 'Rebound';
      ev.needsContext = false;
      save();
    } else {
      openGAContext(ev);
    }
  }

  save();
  renderAll();
  vibrate();

  if(type==='goal' || type==='soft_goal') triggerPulse('liveGA','bad');
  if(type==='for_goal') triggerPulse('liveGF','good');

  if (type === 'shot' || type === 'big_save') scheduleGoodReboundCredit(ev.id);

  return ev;
}

function triggerPulse(elemId, type){
  const el = $(elemId);
  if(!el) return;
  el.classList.remove('pulse-good', 'pulse-bad');
  void el.offsetWidth;
  el.classList.add(type==='good'?'pulse-good':'pulse-bad');
}

function undo(){
  const ev = state.events.pop();
  if(!ev) return;
  revert(ev);
  renderAll();
  vibrate(15);
}
function revert(ev){
  clearGoodPendingFor(ev.id);
  const p = per[ev.period] || per[4];

  if(ev.type==='shot'){ state.countsA.shots--; p.A_shots--; }
  else if(ev.type==='goal'){ state.countsA.shots--; state.countsA.goals--; p.A_shots--; p.A_goals--; }
  else if(ev.type==='soft_goal'){ state.countsA.shots--; state.countsA.goals--; state.countsA.softGoals--; p.A_shots--; p.A_goals--; }
  else if(ev.type==='smother'){ state.countsA.smothers--; p.A_smothers--; }
  else if(ev.type==='bad_rebound'){ state.countsA.shots--; state.countsA.badRebounds--; p.A_shots--; p.A_badRebounds--; }
  else if(ev.type==='big_save'){ state.countsA.bigSaves--; state.countsA.shots--; p.A_bigSaves--; p.A_shots--; }
  else if(ev.type==='for_shot'){ state.countsF.shots--; p.F_shots--; }
  else if(ev.type==='for_goal'){ state.countsF.shots--; state.countsF.goals--; p.F_shots--; p.F_goals--; }
  else if(ev.type==='breakaway_against'){ state.team.breakawaysAgainst--; p.BA--; }
  else if(ev.type==='dz_turnover'){ state.team.dzTurnovers--; p.DZ--; }
  else if(ev.type==='breakaway_for'){ state.team.breakawaysFor--; p.BF--; }
  else if(ev.type==='odd_man_rush_for'){ state.team.oddManRushFor--; p.OMRF--; }

  save();
}

/* Undo Hold Logic */
let undoHoldTimer = null, undoHeld = false, undoPointerActive = false;
function startUndoHold(){
  if(undoPointerActive)return;
  undoPointerActive=true;
  undoHeld=false;
  undoHoldTimer=setTimeout(()=>{undoHeld=true;showUndoModal();},600);
}
function finishUndo(){
  if(!undoPointerActive)return;
  undoPointerActive=false;
  if(undoHoldTimer){clearTimeout(undoHoldTimer);undoHoldTimer=null;}
  if(!undoHeld){undo();}
}
function cancelUndoHold(){
  if(!undoPointerActive)return;
  undoPointerActive=false;
  if(undoHoldTimer){clearTimeout(undoHoldTimer);undoHoldTimer=null;}
}
const undoBtn = $('btnUndo');
if(undoBtn){
  undoBtn.addEventListener('pointerdown',startUndoHold);
  undoBtn.addEventListener('pointerup',finishUndo);
  undoBtn.addEventListener('pointerleave',cancelUndoHold);
  undoBtn.addEventListener('pointercancel',cancelUndoHold);
}

/* Undo Modal */
let lastRemoved = null, toastTimer = null;
function showUndoModal(){
  const listEl = $('undoList');
  const recent = state.events.slice(-5);
  listEl.innerHTML = recent.length
    ? recent.map(ev=>`<div class="undoRow" data-id="${ev.id}">P${ev.period} • ${fmtTime(ev.tISO)} — ${labelFor(ev)}</div>`).reverse().join('')
    : `<div class="small">No events.</div>`;
  $('undoModal').style.display = 'flex';
}
$('undoList').addEventListener('click', e => {
  const row = e.target.closest('.undoRow');
  if(!row)return;
  const id = Number(row.dataset.id);
  const idx = state.events.findIndex(ev => ev.id === id);
  if(idx===-1) return;
  const [ev] = state.events.splice(idx,1);
  revert(ev);
  lastRemoved = ev;
  $('undoModal').style.display='none';
  showToast('Removed.');
  renderAll();
});
$('undoClose').addEventListener('click', ()=>$('undoModal').style.display='none');
function showToast(msg){
  const t=$('toast');
  t.firstChild.nodeValue = msg+' ';
  t.style.display='block';
  if(toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(hideToast,3500);
}
function hideToast(){
  $('toast').style.display='none';
  if(toastTimer){clearTimeout(toastTimer);toastTimer=null;}
}
$('toastRestore').addEventListener('click', ()=>{
  if(!lastRemoved){ hideToast(); return; }
  const ev = lastRemoved;
  lastRemoved=null;
  state.events.push(ev);
  state.events.sort((a,b)=>new Date(a.tISO)-new Date(b.tISO));
  rebuildFromEvents();
  save();
  renderAll();
  hideToast();
});

/* Labels */
function labelFor(ev){
  let label = ev.type
    .replace('soft_goal','Soft Goal')
    .replace('bad_rebound','Bad Rebound')
    .replace('for_shot','Our Shot')
    .replace('for_goal','Our Goal')
    .replace('breakaway_against','Breakaway Ag')
    .replace('dz_turnover','DZ Turnover')
    .replace('breakaway_for','Breakaway For')
    .replace('odd_man_rush_for','Odd Man Rush For')
    .replace(/_/g,' ');

  if(ev.type==='for_goal'){
    const s = ev.player && ev.player!=='?' ? ev.player : 'Unknown';
    const a = (ev.assist===null || ev.assist===undefined) ? '—' : (ev.assist==='?' ? 'Unknown' : ev.assist);
    label = `Our Goal (#${s}) A: ${a==='—' ? '—' : '#'+a}`;

    if(ev.off_ctx === 'Breakaway') label += ' [BA]';
    else if(ev.off_ctx === 'Odd Man Rush') label += ' [OMR]';
  }

  if((ev.type==='for_shot')&&ev.player&&ev.player!=='?'&&ev.player!=='Unknown') {
    label+=` (#${ev.player})`;
  }
  return label;
}

/* GA Context */
const GA_TAGS = ['Screen','Deflection','Cross-Crease','Weak-Side','Rush','Rebound','Other'];
let lastGAEvent = null;
function openGAContext(ev){
  lastGAEvent = ev;

  // if we’re opening the modal, we’re actively tagging now
  lastGAEvent.needsContext = false;
  save();

  $('gaGrid').innerHTML = GA_TAGS.map(t=>`<div class="pickerBtn" data-t="${t}">${t}</div>`).join('');
  $('gaOverlay').style.display = 'flex';
}

$('gaGrid').addEventListener('click', e=>{
  const chip=e.target.closest('.pickerBtn');
  if(!chip||!lastGAEvent)return;
  lastGAEvent.ga_ctx=chip.dataset.t;
  lastGAEvent.needsContext = false;
  save();
  $('gaOverlay').style.display='none';
  renderAll();

  openMultiPicker({title:'5 Players On Ice (required)', max:5, event:lastGAEvent, field:'onIce', exclude:[]});
  lastGAEvent=null;
});
$('gaSkip').addEventListener('click', ()=>{
  $('gaOverlay').style.display='none';
  if(lastGAEvent){
    lastGAEvent.needsContext = true;
    save();
    renderAll();

    // still prompt on-ice (optional) then strength (required)
    openMultiPicker({title:'5 Players On Ice (optional)', max:5, event:lastGAEvent, field:'onIce', exclude:[]});
    // we keep lastGAEvent for the picker chain
  }
});

/* IMPORTANT CHANGE: BR (bad rebound -> goal) is 5s window; BA/DZ remain 10s */
function tagGACause(gaEv){
  const tGA = new Date(gaEv.tISO).getTime();

  // BA/DZ window = 10s
  let windowStart = tGA - 10000;

  // Prevent bleed across goals:
  // only allow context events after the previous GA/soft GA
  for(let i = state.events.length - 1; i >= 0; i--){
    const ev = state.events[i];
    if(ev === gaEv) continue;

    const t = new Date(ev.tISO).getTime();
    if(t >= tGA) continue;

    if(ev.type === 'goal' || ev.type === 'soft_goal'){
      windowStart = Math.max(windowStart, t + 1);
      break;
    }
  }

  const brWindowStart = Math.max(windowStart, tGA - 5000); // BR window = 5s

  let hasBA = false, hasDZ = false, hasBR = false;

  for(const ev of state.events){
    const t = new Date(ev.tISO).getTime();
    if(t > tGA) continue;

    // BA/DZ check within 10s window
    if(t >= windowStart){
      if(ev.type === 'breakaway_against') hasBA = true;
      if(ev.type === 'dz_turnover') hasDZ = true;
    }

    // BR check within 5s window
    if(t >= brWindowStart){
      if(ev.type === 'bad_rebound') hasBR = true;
    }
  }

  const parts = [];
  gaEv.ga_ba = !!hasBA;
  gaEv.ga_dz = !!hasDZ;
  gaEv.ga_br = !!hasBR;

  if(gaEv.ga_ba) parts.push('BA');
  if(gaEv.ga_dz) parts.push('DZ');
  if(gaEv.ga_br) parts.push('BR');

  gaEv.ga_cause = parts.length ? parts.join('+') : 'other';
  save();
}

  /* Goals For context tagging (10s window, no bleed across Goals For) */
function tagGFCause(gfEv){
  const tGF = new Date(gfEv.tISO).getTime();

  // 10s window for offensive context
  let windowStart = tGF - 10000;

  // Prevent bleed across Goals For:
  // only allow context events after the previous for_goal
  for(let i = state.events.length - 1; i >= 0; i--){
    const ev = state.events[i];
    if(ev === gfEv) continue;

    const t = new Date(ev.tISO).getTime();
    if(t >= tGF) continue;

    if(ev.type === 'for_goal'){
      windowStart = Math.max(windowStart, t + 1);
      break;
    }
  }

  let hasBA = false;
  let hasOMR = false;

  for(const ev of state.events){
    const t = new Date(ev.tISO).getTime();
    if(t < windowStart || t > tGF) continue;

    if(ev.type === 'breakaway_for') hasBA = true;
    if(ev.type === 'odd_man_rush_for') hasOMR = true;
  }

  // Priority: Breakaway > Odd Man Rush > Other
  if(hasBA) gfEv.off_ctx = 'Breakaway';
  else if(hasOMR) gfEv.off_ctx = 'Odd Man Rush';
  else gfEv.off_ctx = 'Other';

  save();
}

/* Multi Picker */
let multiPick = {selected:new Set(), unknowns:0, max:5, exclude:new Set(), eventRef:null, field:'onIce'};
function openMultiPicker({title,max,event,field,exclude}){
  multiPick={selected:new Set(), unknowns:0, max, exclude:new Set(exclude||[]), eventRef:event, field};
  $('onIceTitle').textContent=title;
  $('onIceMax').textContent=String(max);
  $('onIceModal').style.display='flex';
  buildOnIceGrid();
  updateOnIceMeta();
}
function buildOnIceGrid(){
  const roster=sortRoster((state.roster||[]).map(x=>String(x).trim()).filter(Boolean));
  const uniq=Array.from(new Set(roster)).filter(n=>!multiPick.exclude.has(n));
  $('onIceGrid').innerHTML=uniq.length
    ? uniq.map(n=>`<div class="pickerBtn ${multiPick.selected.has(n)?'selected':''}" data-n="${n}">#${n}</div>`).join('')
    : `<div class="small" style="grid-column:1/-1;">No roster yet.</div>`;
}
function totalSelected(){
  return multiPick.selected.size + multiPick.unknowns;
}
function updateOnIceMeta(){
  $('onIceCount').textContent=String(totalSelected());
  $('onIceUnknownBadge').textContent=`Unknown ×${multiPick.unknowns}`;
}
$('onIceGrid').addEventListener('click',e=>{
  const b=e.target.closest('.pickerBtn');
  if(!b)return;
  const n=b.dataset.n;
  if(multiPick.selected.has(n)){
    multiPick.selected.delete(n);
    b.classList.remove('selected');
  }
  else{
    if(totalSelected()>=multiPick.max)return;
    multiPick.selected.add(n);
    b.classList.add('selected');
  }
  updateOnIceMeta();
});
$('onIceUnknownPlus').addEventListener('click', ()=>{
  if(totalSelected()>=multiPick.max)return;
  multiPick.unknowns++;
  updateOnIceMeta();
});
$('onIceUnknownMinus').addEventListener('click', ()=>{
  if(multiPick.unknowns>0){multiPick.unknowns--; updateOnIceMeta();}
});
$('onIceClear').addEventListener('click', ()=>{
  multiPick.selected.clear();
  multiPick.unknowns=0;
  buildOnIceGrid();
  updateOnIceMeta();
});
  // Allow typing a number into the on-ice picker (adds to roster + selects it)
$('onIceAdd').addEventListener('click', () => {
  const input = $('onIceInput');
  if (!input) return;

  const raw = (input.value || '').trim();
  if (!raw) return;

  // Only allow digits for roster numbers
  if (!/^\d+$/.test(raw)) {
    input.value = '';
    return;
  }

  // Respect max selection count
  if (totalSelected() >= multiPick.max) {
    input.value = '';
    return;
  }

  // Add to roster (and persist) if new
  ensureRosterNumber(raw);

  // Select it in this modal
  multiPick.selected.add(String(raw));

  // Rebuild grid so the new number appears (and shows selected state)
  buildOnIceGrid();
  updateOnIceMeta();

  input.value = '';
});

// Pressing Enter on the keyboard should also "Use"
$('onIceInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    $('onIceAdd').click();
  }
});

$('onIceUse').addEventListener('click', ()=>{
  if(!multiPick.eventRef){
    $('onIceModal').style.display='none';
    return;
  }
  const ev=multiPick.eventRef, arr=[...multiPick.selected];
  for(let i=0;i<multiPick.unknowns;i++) arr.push('Unknown');
  ev[multiPick.field]=arr;
  save();
  $('onIceModal').style.display='none';
  multiPick.eventRef=null;
  renderAll();

  // Strength required after any goal for/against (and soft goal)
  if(ev.type==='goal'||ev.type==='soft_goal'||ev.type==='for_goal') openStrengthPicker(ev, 'Situation (required)');
});
$('onIceCancel').addEventListener('click', ()=>{
  const ev = multiPick.eventRef;
  $('onIceModal').style.display='none';
  multiPick.eventRef=null;

  if(ev && (ev.type==='goal'||ev.type==='soft_goal'||ev.type==='for_goal')){
    openStrengthPicker(ev, 'Situation (required)');
  }
});

/* Strength */
let strengthTarget=null;
function openStrengthPicker(ev, label){
  strengthTarget=ev;
  $('strengthTitle').textContent=label;
  $('strengthModal').style.display='flex';
}
$('strengthModal').addEventListener('click', e=>{
  const b=e.target.closest('.pickerBtn');
  if(!b||!strengthTarget)return;
  strengthTarget.strength=b.dataset.strength;
  save();
  $('strengthModal').style.display='none';
  strengthTarget=null;
  renderAll();
});
$('strengthSkip').addEventListener('click', ()=>{
  // requirement: prompt exists; allow skip, but leave undefined
  $('strengthModal').style.display='none';
  strengthTarget=null;
  renderAll();
});

/* PlusMinus / Stats / Scoring */
/* ===== Scoring helpers (NEW) ===== */

function bayesRate(success, trials, priorRate, priorWeight){
  const s = Math.max(0, success);
  const t = Math.max(0, trials);
  const w = Math.max(0, priorWeight);
  const pr = Math.max(0, Math.min(1, priorRate));
  return (s + pr*w) / (t + w || 1);
}
function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }

// Pulls goal difficulty/blame weight from the GA metadata you already capture.
// < 1.0 means "harder / more team-caused / less goalie blame"
// > 1.0 means "easier / more goalie blame"
function gaBlameWeight(ev){
  let w = 1.0;

  const strength = ev.strength || 'UNK';
  const ctx = ev.ga_ctx || '';
  const cause = ev.ga_cause || '';

  // Strength
  if(strength === 'PP') w *= 0.90;
  else if(strength === 'SH') w *= 0.92;

  // Cause flags (BA/DZ/BR)
  if(cause.includes('BA')) w *= 0.78;
  if(cause.includes('DZ')) w *= 0.86;
  if(cause.includes('BR')) w *= 1.10;

  // Context tags (GA_TAGS)
  if(/Screen/i.test(ctx)) w *= 0.82;
  if(/Deflection/i.test(ctx)) w *= 0.78;
  if(/Cross-Crease/i.test(ctx)) w *= 0.75;
  if(/Weak-Side/i.test(ctx)) w *= 0.84;
  if(/Rush/i.test(ctx)) w *= 0.88;
  if(/Rebound/i.test(ctx)) w *= 1.12;

  // Soft goals
  if(ev.type === 'soft_goal') w *= 1.35;

  return clamp(w, 0.55, 1.60);
}

// Uses your player stats: depth, assist rate, plus/minus distribution
function computeTeamDepthAndInvolvement(){
  const players = computePlayerStats(); // already exists later in the file
  const {pm, order} = computePlusMinus(); // already exists just above scoring

  // Goals distribution (depth)
  const goals = players.map(p => p.goals).filter(g => g > 0);
  const totalGoals = goals.reduce((a,b)=>a+b,0);

  let depth01 = 0.5; // neutral default
  if(totalGoals >= 2 && goals.length >= 2){
    // HHI concentration
    const hhi = goals.reduce((acc,g)=>acc + (g/totalGoals)*(g/totalGoals), 0);
    // Normalize: 0 = one player scores everything, 1 = perfectly spread among goal scorers
    const n = goals.length;
    const hhiMin = 1/n;
    const hhiMax = 1;
    depth01 = 1 - ((hhi - hhiMin) / (hhiMax - hhiMin || 1));
    depth01 = clamp(depth01, 0, 1);
  }

  // Assist rate (team play): known assists only
  const knownAssists = state.events.filter(e=>e.type==='for_goal' && e.assist && e.assist!=='?').length;
  const GF = state.countsF.goals;
  const assistRate = GF > 0 ? knownAssists / GF : 0.5;
  const assist01 = clamp((assistRate - 0.20) / 0.60, 0, 1);

  // Plus/minus distribution (light touch)
  let neg2 = 0, pos2 = 0;
  for(const n of order){
    const v = pm.get(n) || 0;
    if(v <= -2) neg2++;
    if(v >=  2) pos2++;
  }
  const pmAdj = clamp(0.5 + 0.08*(pos2 - neg2), 0, 1);

  return { depth01, assist01, pmAdj, assistRate, knownAssists, neg2, pos2 };
}

function computePlusMinus(){
  const pm=new Map();
  function inc(n,d){
    const s = String(n||'').trim();
    if(!s || s==='Unknown' || s==='?') return;
    pm.set(s,(pm.get(s)||0)+d);
  }

  for(const ev of state.events){
    if(ev.type==='for_goal'){
      const s=new Set();
      if(ev.player) s.add(ev.player);
      if(ev.assist) s.add(ev.assist);
      (ev.forOnIce||[]).forEach(x=>s.add(x));
      for(const n of s) inc(n,1);
    }
    if((ev.type==='goal'||ev.type==='soft_goal')&&ev.onIce){
      for(const n of ev.onIce) inc(n,-1);
    }
  }
  const order = sortRoster([...pm.keys()]);
  return {pm, order};
}

function normalizeLevelKey(levelStr){
  const s = String(levelStr||'').toUpperCase();
  const m = s.match(/U\d{1,2}/);
  return m ? m[0] : 'Other';
}

const LEVEL_PROFILES = {
  U9:  { goalieBaseSV:0.75, teamFinExp:0.20, minShots:10 },
  U11: { goalieBaseSV:0.80, teamFinExp:0.17, minShots:15 },
  U13: { goalieBaseSV:0.82, teamFinExp:0.15, minShots:18 },
  U15: { goalieBaseSV:0.86, teamFinExp:0.13, minShots:22 },
  U18: { goalieBaseSV:0.89, teamFinExp:0.12, minShots:25 },
  Other:{ goalieBaseSV:0.85, teamFinExp:0.14, minShots:20 }
};

function computeGoalieScore(){
  const C = state.countsA;
  const shots = C.shots;
  const ga = C.goals;
  const saves = Math.max(0, shots - ga);

  const prof = LEVEL_PROFILES[normalizeLevelKey(state.level)] || LEVEL_PROFILES.Other;

  // Volume factor (don’t over-credit tiny sample sizes)
  const volFactor = clamp01(shots / prof.minShots);

  // Expected goals against at this level
  const expectedGA = shots * (1 - prof.goalieBaseSV);

  // Main performance: how far above/below expected GA
  const perfNorm = (shots === 0) ? 0.5 : clamp01(0.5 + (expectedGA - ga) / 6);
  let scoreSV = 70 + (perfNorm - 0.5) * 50 * volFactor;   // ~45..95 depending on performance+volume

  // Soft goals: real penalty
  const softPen = Math.max(-24, -8 * C.softGoals);

  // Context blame: only penalize goals that weren’t “high difficulty” situations
  const gas = state.events.filter(e => e.type === 'goal' || e.type === 'soft_goal');
  let ctxBad = 0;

  for(const ev of gas){
    const cause = ev.ga_cause || '';
    const ctx   = ev.ga_ctx || '';

    const hardGoal =
      cause.includes('BA') ||
      /Screen|Deflection|Cross-Crease/.test(ctx) ||
      (ev.strength === 'SH');

    if(!hardGoal){
      ctxBad += 1.0;

      // Rebound goals slightly more blame (if tagged)
      if(cause.includes('BR') || /Rebound/.test(ctx)) ctxBad += 0.5;

      // Soft goal adds blame too
      if(ev.type === 'soft_goal') ctxBad += 0.5;

      // PP GA slightly less blame than EV GA
      if(ev.strength === 'PP') ctxBad -= 0.5;
    }
  }

  const ctxAdj = gas.length ? -Math.min(8, (ctxBad / gas.length) * 3) : 0;

  // Rebound control:
  // "goodRebound" is UNRESOLVED, not positive. Only smothers vs bad rebounds matter.
  const goodRebCount = state.events.filter(e => e.goodRebound).length; // for audit display only
  const sm = C.smothers;
  const br = C.badRebounds;

  const denom = sm + br;
  let scoreReb = 0;

  if(denom === 0){
    scoreReb = 2 * volFactor; // neutral baseline
  } else {
    const smShare = sm / denom;
    const brShare = br / denom;
    scoreReb = (6 * smShare - 6 * brShare) * volFactor; // -6..+6 scaled
    scoreReb = Math.max(0, Math.min(6, scoreReb));      // clamp so it can’t dominate
  }

  // Big saves: small cap, only matters with real volume
  const bigVol = clamp01(shots / 20);
  const scoreBig = Math.min(4, 0.6 * C.bigSaves) * bigVol; // max 4

  let total = Math.round(scoreSV + softPen + ctxAdj + scoreReb + scoreBig);

  // Ceiling: no 100 when GA exists
  const maxCap = Math.max(0, Math.min(100, 100 - 3 * ga - 2 * C.softGoals));
  total = Math.min(total, maxCap);

  total = Math.max(0, Math.min(100, total));

  return {
    total,
    scoreSV: Math.round(scoreSV),
    softPenalty: Math.round(softPen),
    ctxAdj: Math.round(ctxAdj),
    scoreRebound: Math.round(scoreReb),
    scoreBig: Math.round(scoreBig),
    goodRebounds: goodRebCount
  };
}

function computeTeamScore(){
  const SF = state.countsF.shots;
  const SA = state.countsA.shots;
  const GF = state.countsF.goals;
  const GA = state.countsA.goals;

  const prof = LEVEL_PROFILES[normalizeLevelKey(state.level)] || LEVEL_PROFILES.Other;

  const totalShots = SF + SA;
  const vol = clamp01(totalShots / (2 * prof.minShots));

  // Puck control (shot share) with stabilization toward 50/50
  const ssPrior = Math.max(14, Math.round(prof.minShots * 0.8));
  const SS = (SF + 0.5*ssPrior) / (totalShots + ssPrior || 1);

  // Finishing stabilized toward level expectation
  const finPrior = Math.max(10, Math.round(prof.minShots * 0.5));
  const Fin = SF > 0 ? (GF / SF) : 0;
  const FinPost = bayesRate(GF, SF, prof.teamFinExp, finPrior);

  // Results: scaled by event size
  const goalDiff = GF - GA;
  const scale = Math.max(3, Math.sqrt(totalShots));
  const Impact01 = clamp01(0.5 + (goalDiff / scale) * 0.55);

  // Chance creation: uses offensive context + GF context tags
  const gfCtx = computeGFContextBreakdown();
  const chanceRaw =
    (1.2*state.team.breakawaysFor + 0.8*state.team.oddManRushFor +
     1.8*gfCtx.BA + 1.2*gfCtx.OMR) / Math.max(1, SF);
  const chance01 = clamp01(chanceRaw / 0.06);

  // Defensive discipline: uses BA Ag + DZ TO + GA causes
  const gaCause = computeGABreakdown();
  const dangerRaw =
    (1.2*state.team.breakawaysAgainst + 0.8*state.team.dzTurnovers +
     1.6*gaCause.BA + 1.1*gaCause.DZ + 1.3*gaCause.BR) / Math.max(1, SA);
  const danger01 = clamp01(dangerRaw / 0.06);

  // Special teams (light): goals by strength only
  const sb = computeStrengthBreakdown();
  const gfPP = sb.for.PP || 0, gfSH = sb.for.SH || 0;
  const gaPP = sb.against.PP || 0, gaSH = sb.against.SH || 0;

  const goalsTotal = Math.max(1, GF + GA);
  const stNet = (gfPP + 1.3*gfSH) - (1.4*gaPP + 1.0*gaSH);
  const st01 = clamp01(0.5 + 0.5 * clamp(stNet / goalsTotal, -1, 1));

  // Consistency by period
  const pVals = [1,2,3,4]
    .map(p => (per[p].F_shots + per[p].A_shots) > 0 ? per[p].F_shots/(per[p].F_shots+per[p].A_shots) : null)
    .filter(v => v !== null);

  let stab01 = 0.5;
  if(pVals.length > 1){
    const mu = pVals.reduce((a,b)=>a+b,0)/pVals.length;
    const sig = Math.sqrt(pVals.reduce((a,b)=>a+(b-mu)**2,0)/pVals.length);
    stab01 = clamp01(1 - (sig / 0.22));
  }

  // Depth + involvement (player stats)
  const di = computeTeamDepthAndInvolvement();
  const depth01 = di.depth01;
  const teamplay01 = di.assist01;
  const pm01 = di.pmAdj;

  // Convert sub-scores into points
  const possScaled = clamp01(0.5 + (SS - 0.5) * 1.45);
  const scoreSS = 30 * possScaled;

  const finScaled = clamp01(FinPost / Math.max(0.04, prof.teamFinExp * 1.35));
  const scoreFin = 20 * finScaled;

  const scoreImp = 25 * Impact01;
  const scoreChance = 10 * chance01;
  const scoreStab = 5 * stab01;
  const scoreST = 5 * st01;

  const scoreDepth = 5 * clamp01(0.55*depth01 + 0.30*teamplay01 + 0.15*pm01);

  const penDef = 10 * danger01;

  let total = scoreSS + scoreFin + scoreImp + scoreChance + scoreStab + scoreST + scoreDepth - penDef;

  // Small-sample damping
  total = 50 + (total - 50) * (0.35 + 0.65*vol);

  total = Math.round(clamp(total, 0, 100));

  return {
    total,
    scoreSS,
    scoreFin,
    scoreImp,
    scoreStab,
    SS,
    Fin,

    // optional extras (won’t break anything)
    scoreChance,
    scoreST,
    scoreDepth,
    penDef
  };
}

/* GA breakdown helper */
function computeGABreakdown(){
  return state.events.reduce((acc,e)=>{
    if(e.type==='goal'||e.type==='soft_goal'){
      const c=e.ga_cause||'';
      if(e.ga_ba||c.includes('BA')) acc.BA++;
      else if(e.ga_dz||c.includes('DZ')) acc.DZ++;
      else if(e.ga_br||c.includes('BR')) acc.BR++;
      else acc.Other++;
    }
    return acc;
  }, {BA:0,DZ:0,BR:0,Other:0});
}

function computeGFContextBreakdown(){
  const acc = {BA:0, OMR:0, Other:0};

  for(let i = 0; i < state.events.length; i++){
    const e = state.events[i];
    if(e.type !== 'for_goal') continue;

    // If already tagged, trust it
    if(e.off_ctx === 'Breakaway') { acc.BA++; continue; }
    if(e.off_ctx === 'Odd Man Rush') { acc.OMR++; continue; }
    if(e.off_ctx === 'Other') { acc.Other++; continue; }

    // Otherwise compute with no bleed across previous for_goal
    const tGoal = new Date(e.tISO).getTime();
    let windowStart = tGoal - 10000;

    for(let j = i - 1; j >= 0; j--){
      const prior = state.events[j];
      const t = new Date(prior.tISO).getTime();
      if(t >= tGoal) continue;
      if(prior.type === 'for_goal'){
        windowStart = Math.max(windowStart, t + 1);
        break;
      }
    }

    let hasBA = false, hasOMR = false;
    for(let j = i - 1; j >= 0; j--){
      const prior = state.events[j];
      const t = new Date(prior.tISO).getTime();
      if(t < windowStart) break;

      if(prior.type === 'breakaway_for') hasBA = true;
      if(prior.type === 'odd_man_rush_for') hasOMR = true;
    }

    if(hasBA) acc.BA++;
    else if(hasOMR) acc.OMR++;
    else acc.Other++;
  }

  return acc;
}

/* Strength breakdown */
function computeStrengthBreakdown(){
  const out = {
    for:{EV:0,PP:0,SH:0,UNK:0},
    against:{EV:0,PP:0,SH:0,UNK:0}
  };
  for(const ev of state.events){
    if(ev.type==='for_goal'){
      const s = ev.strength || 'UNK';
      out.for[s] = (out.for[s]||0)+1;
    }
    if(ev.type==='goal' || ev.type==='soft_goal'){
      const s = ev.strength || 'UNK';
      out.against[s] = (out.against[s]||0)+1;
    }
  }
  return out;
}

/* ===== Live Renders ===== */
function setRing(valEl, arcEl, sc){
  if(!valEl || !arcEl) return;

  // Show placeholder when score is null/undefined
  if(sc === null || sc === undefined || sc === '—'){
    valEl.textContent = '—';
    arcEl.style.stroke = '#333';
    arcEl.style.strokeDashoffset = '220'; // empty ring
    return;
  }

  valEl.textContent = sc;
  const c = sc>=85 ? '#32d74b' : sc>=70 ? '#ff9f0a' : '#ff453a';
  arcEl.style.stroke = c;
  arcEl.style.strokeDashoffset = String(220*(1-sc/100));
}

function updateMeta(){
  const F=state.countsF, A=state.countsA;

  $('liveGF').textContent = F.goals;
  $('liveGA').textContent = A.goals;

  $('liveSF_sub').textContent = `SF: ${F.shots}`;
  $('liveSA_sub').textContent = `SA: ${A.shots}`;

  const saves=Math.max(0,A.shots-A.goals);
  const svText = A.shots ? (saves/A.shots).toFixed(3).slice(1) : '—';

  $('dashLine').textContent = `GF ${F.goals} • GA ${A.goals} • SF ${F.shots} • SA ${A.shots}`;

  $('savesVal').textContent = saves;
  $('svVal').textContent = `SV% ${svText}`;

  $('smothersVal').textContent = state.countsA.smothers;
  $('badRebVal').textContent = state.countsA.badRebounds;
  $('bigSavesVal').textContent = state.countsA.bigSaves;
  $('softVal').textContent = state.countsA.softGoals;

  $('baAgVal').textContent = state.team.breakawaysAgainst;
  $('dzVal').textContent = state.team.dzTurnovers;
  $('baForVal').textContent = state.team.breakawaysFor;
  $('omrForVal').textContent = state.team.oddManRushFor;

  const goodReb = state.events.filter(e=>e.goodRebound).length;
  $('goodRebVal').textContent = goodReb;

  const shootPct = F.shots ? (F.goals/F.shots).toFixed(3).slice(1) : '—';
  $('shootPctVal').textContent = shootPct;

  const share = (F.shots + A.shots) ? Math.round(100 * (F.shots/(F.shots+A.shots)))+'%' : '—';
  $('shotShareVal').textContent = share;

// rings
if(state.events.length === 0){
  // start-of-game display
  $('goalieScoreNum').textContent = '—';
  $('teamScoreNum').textContent = '—';
  $('gsArc').style.stroke = '#333';
  $('tsArc').style.stroke = '#333';
  $('gsArc').style.strokeDashoffset = '220';
  $('tsArc').style.strokeDashoffset = '220';
} else {
  const K = computeGoalieScore(), T = computeTeamScore();
  setRing($('goalieScoreNum'),$('gsArc'),K.total);
  setRing($('teamScoreNum'),$('tsArc'),T.total);
}


  // per-period cards (clean: header already says P1/P2/P3/OT)
  function pLine(p){
    const v = per[p];
    // Big line: just the score for that period (GF–GA)
    return `${v.F_goals}–${v.A_goals}`;
  }
  function pSub(p){
    const v = per[p];
    // Small line: shots
    return `SF ${v.F_shots} • SA ${v.A_shots}`;
  }

  $('p1Line').textContent = pLine(1);
  $('p2Line').textContent = pLine(2);
  $('p3Line').textContent = pLine(3);
  $('p4Line').textContent = pLine(4);

  // Put the shots line into the .s text inside each tile (ONLY ONCE)
  const pTiles = [
    {id:'p1Line', p:1},{id:'p2Line', p:2},{id:'p3Line', p:3},{id:'p4Line', p:4},
  ];
  for(const it of pTiles){
    const el = $(it.id);
    if(el && el.parentElement && el.parentElement.querySelector('.s')){
      el.parentElement.querySelector('.s').textContent = pSub(it.p);
    }
  }

  updateDebugLines();
}

function renderLog(){
  const logEl = $('log');
  if(!logEl) return;
  const evs = [...state.events].sort((a,b)=>new Date(a.tISO)-new Date(b.tISO));
  if(!evs.length){
    logEl.innerHTML = `<div class="small" style="opacity:0.7;">No events yet.</div>`;
    return;
  }
  logEl.innerHTML = evs.map(ev=>{
    const isGA = (ev.type==='goal' || ev.type==='soft_goal');
    const ctx = ev.ga_ctx || '';
    const cause = ev.ga_cause || '';
    const tags = [];
    if(isGA){
      if(cause) tags.push(cause);
      if(ctx) tags.push(ctx);
    }
    if(ev.type==='for_goal' && ev.off_ctx) tags.push(`OF:${ev.off_ctx}`);
    if(ev.strength) tags.push(ev.strength);

    const tagText = tags.join(' • ');
    const needs = ev.needsContext && isGA;
    const meta = `P${ev.period} • ${fmtTime(ev.tISO)}`;
    return `
      <div class="log-item" data-id="${ev.id}">
        <div class="log-main">
          <span class="log-meta">${meta}</span>
          <span>${labelFor(ev)}</span>
          ${tagText ? `<span class="badge">${tagText}</span>` : ''}
        </div>
        ${needs ? `<span class="badge badge-tag" data-id="${ev.id}">Tag</span>` : ''}
      </div>`;
  }).join('');
}

/* Handle Tag Later from log */
$('log').addEventListener('click', e=>{
  const badge = e.target.closest('.badge-tag');
  if(!badge) return;
  const id = Number(badge.dataset.id);
  const ev = state.events.find(x=>x.id===id);
  if(!ev) return;

  // user is tagging now, so stop showing "Tag" immediately
  ev.needsContext = false;
  save();

  openGAContext(ev);
});

/* ===== Summary Building ===== */
function buildAllStatsHTML(){
  const SF=state.countsF.shots, SA=state.countsA.shots, GF=state.countsF.goals, GA=state.countsA.goals;
  const saves=Math.max(0,SA-GA);
  const svText = SA ? (saves/SA).toFixed(3).slice(1) : '—';
  const shootPct = SF ? (GF/SF).toFixed(3).slice(1) : '—';
  const share = (SF+SA) ? Math.round(100*(SF/(SF+SA)))+'%' : '—';
  const goodReb = state.events.filter(e=>e.goodRebound).length;

  // GA cause breakdown
  const gaStats = computeGABreakdown();

  // GF context breakdown
  const gfCtx = computeGFContextBreakdown();

  const rows = [
    ['GF', GF], ['GA', GA], ['SF', SF], ['SA', SA],
    ['Saves', saves], ['SV%', svText], ['Our Shooting%', shootPct], ['Shot Share', share],
    ['Smothers', state.countsA.smothers], ['Bad Rebounds', state.countsA.badRebounds], ['Big Saves', state.countsA.bigSaves], ['Soft Goals', state.countsA.softGoals],
    ['Breakaways Ag', state.team.breakawaysAgainst], ['D-Zone TO', state.team.dzTurnovers], ['Breakaways For', state.team.breakawaysFor], ['Odd Man Rush For', state.team.oddManRushFor],
    ['Good Rebounds', goodReb],

    ['GF off BA', gfCtx.BA], ['GF off OMR', gfCtx.OMR], ['GF Other', gfCtx.Other],

    ['GA off BA', gaStats.BA], ['GA off DZ', gaStats.DZ], ['GA off Bad Reb', gaStats.BR], ['GA Other', gaStats.Other]

  ];

  let html = `<table><tr><th>Stat</th><th>Value</th><th>Stat</th><th>Value</th></tr>`;
  for(let i=0;i<rows.length;i+=2){
    const a=rows[i], b=rows[i+1];
    html += `<tr><td>${a[0]}</td><td>${a[1]}</td><td>${b?b[0]:''}</td><td>${b?b[1]:''}</td></tr>`;
  }
  html += `</table>`;
  return html;
}

function endGame(){
  const K=computeGoalieScore(), T=computeTeamScore();
  const date = state.date || new Date().toISOString().slice(0,10);

  $('summaryTitle').textContent = `${state.opponent || 'Opponent ?'} • ${state.level || '?'} • ${date}`;

  $('scoreBreakdown').textContent = `SV: ${K.scoreSV} | Ctx: ${K.ctxAdj} | Soft: ${K.softPenalty} | Reb: ${K.scoreRebound} | Big: ${K.scoreBig} | Good Reb: ${K.goodRebounds}`;
$('teamBreakdown').textContent =
  `Possession: ${Math.round(T.scoreSS)} | Finish: ${Math.round(T.scoreFin)} | Result: ${Math.round(T.scoreImp)} | ` +
  `Chances: ${Math.round(T.scoreChance||0)} | ST: ${Math.round(T.scoreST||0)} | Depth: ${Math.round(T.scoreDepth||0)} | ` +
  `Discipline Pen: -${Math.round(T.penDef||0)} | Consistency: ${Math.round(T.scoreStab)}`;

  // Summary rings
  setRing($('goalieScoreNumSum'),$('gsArcSum'),K.total);
  setRing($('teamScoreNumSum'),$('tsArcSum'),T.total);

  $('allStatsGrid').innerHTML = buildAllStatsHTML();

  // Strength breakdown
  const sb = computeStrengthBreakdown();
  $('strengthBreakdown').textContent =
    `Goals For — EV ${sb.for.EV||0}, PP ${sb.for.PP||0}, SH ${sb.for.SH||0}, Unk ${sb.for.UNK||0}. ` +
    `Goals Against — EV ${sb.against.EV||0}, PP ${sb.against.PP||0}, SH ${sb.against.SH||0}, Unk ${sb.against.UNK||0}.`;

  // Period table
  let html = `<table><tr><th>P</th><th>SF</th><th>SA</th><th>GF</th><th>GA</th><th>BF</th><th>OMRF</th><th>BA</th><th>DZ</th></tr>`;
  for(let p=1;p<=4;p++){
    const v=per[p];
    html+=`<tr>
      <td>${p===4?'OT':p}</td>
      <td>${v.F_shots}</td><td>${v.A_shots}</td><td>${v.F_goals}</td><td>${v.A_goals}</td>
      <td>${v.BF}</td><td>${v.OMRF}</td><td>${v.BA}</td><td>${v.DZ}</td>
    </tr>`;
  }
  html+=`</table>`;
  $('summaryTableWrap').innerHTML=html;
  $('pmTableWrap').innerHTML=makePlusMinusTable();

  // GF + GA summaries
  const gfCtx = computeGFContextBreakdown();
  const gaStats = computeGABreakdown();

  $('gaDetailWrap').innerHTML = `
    <div class="card" style="margin-top:10px;">
      <h3 style="margin:0 0 6px 0;">Goals For Context</h3>
      <table>
        <tr><th>Context</th><th>Count</th></tr>
        <tr><td>Breakaway</td><td>${gfCtx.BA}</td></tr>
        <tr><td>Odd Man Rush</td><td>${gfCtx.OMR}</td></tr>
        <tr><td>Other</td><td>${gfCtx.Other}</td></tr>
      </table>
    </div>

    <div class="card" style="margin-top:10px;">
      <h3 style="margin:0 0 6px 0;">Goals Against Causes</h3>
      <table>
        <tr><th>Cause</th><th>Count</th></tr>
        <tr><td>Breakaway</td><td>${gaStats.BA}</td></tr>
        <tr><td>D-Zone Turnover</td><td>${gaStats.DZ}</td></tr>
        <tr><td>Bad Rebound</td><td>${gaStats.BR}</td></tr>
        <tr><td>Other</td><td>${gaStats.Other}</td></tr>
      </table>
    </div>
  `;

  $('summaryPanel').classList.remove('hidden');
  window.scrollTo({top:document.body.scrollHeight,behavior:'smooth'});

  // Save summary row automatically on end-game
  const SF=state.countsF.shots, SA=state.countsA.shots, GF=state.countsF.goals, GA=state.countsA.goals;
  const saves=Math.max(0,SA-GA);
  const svText = SA ? (saves/SA).toFixed(3).slice(1) : '—';
  const shootPct = SF ? (GF/SF).toFixed(3).slice(1) : '—';
  const share = (SF+SA) ? (SF/(SF+SA)) : 0.5;

  const gameData = {
    Date: date,
    Opponent: state.opponent,
    Level: state.level,
    TeamScore: T.total,
    GoalieScore: K.total,
    GF, GA, SF, SA,
    Saves: saves,
    SVPct: svText,
    OurShootingPct: shootPct,
    ShotShare: share,
    BreakawaysAgainst: state.team.breakawaysAgainst,
    DZTurnovers: state.team.dzTurnovers,
    BreakawaysFor: state.team.breakawaysFor,
    OddManRushFor: state.team.oddManRushFor,
    Smothers: state.countsA.smothers,
    BadRebounds: state.countsA.badRebounds,
    BigSaves: state.countsA.bigSaves,
    SoftGoals: state.countsA.softGoals,
    GA_BA: gaStats.BA,
    GA_DZ: gaStats.DZ,
    GA_BR: gaStats.BR,
    GA_Other: gaStats.Other
  };

  saveGameToAirtable(gameData);
}

async function saveGameToAirtable(game){
  try{
    setCloudStatus('Cloud: Saving…','warn');
    const res = await fetch('/api/save-game',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({game})
    });
    const d=await res.json();
    if(d.success){
      localStorage.setItem(LAST_SAVED_KEY, state.gameId);
      setCloudStatus('Cloud: Saved','good');
      alert('Saved to Airtable!');
    }else{
      setCloudStatus('Cloud: Error','bad');
      alert('Save Failed');
    }
  }catch(e){
    console.error(e);
    setCloudStatus('Cloud: Error','bad');
    alert('Error saving.');
  }
}

/* CSV Helpers: game row + per-player block */
function computePlayerStats(){
  const stats = new Map();
  function ensure(n){
    const s = String(n||'').trim();
    if(!s || s==='Unknown' || s==='?') return null;
    if(!stats.has(s)){
      stats.set(s,{player:s, shots:0, goals:0, assists:0, pm:0});
    }
    return stats.get(s);
  }
  for(const ev of state.events){
    if(ev.type==='for_shot'){
      const st = ensure(ev.player);
      if(st) st.shots++;
    }
    if(ev.type==='for_goal'){
      const stS = ensure(ev.player);
      if(stS) stS.goals++;
      const stA = ensure(ev.assist);
      if(stA) stA.assists++;
    }
  }
  // plus/minus
  const {pm} = computePlusMinus();
  for(const [k,v] of pm.entries()){
    const st = ensure(k);
    if(st) st.pm = v;
  }
  return sortRoster([...stats.keys()]).map(k=>stats.get(k));
}

function exportGameCSV(){
  const K=computeGoalieScore(), T=computeTeamScore();
  const date = state.date || new Date().toISOString().slice(0,10);

  const SF=state.countsF.shots, SA=state.countsA.shots, GF=state.countsF.goals, GA=state.countsA.goals;
  const saves=Math.max(0,SA-GA);
  const svText = SA ? (saves/SA).toFixed(3).slice(1) : '';
  const shootPct = SF ? (GF/SF).toFixed(3).slice(1) : '';

  const gameRow = {
    date,
    opponent: state.opponent||'',
    level: state.level||'',
    teamScore: T.total,
    goalieScore: K.total,
    GF, GA, SF, SA,
    saves,
    sv: svText,
    ourShooting: shootPct,
    breakawaysAgainst: state.team.breakawaysAgainst,
    dzTurnovers: state.team.dzTurnovers,
    breakawaysFor: state.team.breakawaysFor,
    oddManRushFor: state.team.oddManRushFor,
    smothers: state.countsA.smothers,
    badRebounds: state.countsA.badRebounds,
    bigSaves: state.countsA.bigSaves,
    softGoals: state.countsA.softGoals
  };

  const players = computePlayerStats();

  const gameHeaders = Object.keys(gameRow);
  const gameValues = gameHeaders.map(h => `"${String(gameRow[h]??'').replace(/"/g,'""')}"`);
  let csv = 'GAME\n' + gameHeaders.join(',') + '\n' + gameValues.join(',') + '\n\n';

  csv += 'PLAYERS\n';
  csv += ['player','shots','goals','assists','plusMinus'].join(',') + '\n';
  for(const p of players){
    csv += [`"${p.player}"`, p.shots, p.goals, p.assists, p.pm].join(',') + '\n';
  }

  const blob=new Blob([csv],{type:'text/csv'});
  const fileName = `team-tracker-${date}.csv`;

  // Share sheet if available, else download
  const doDownload = ()=>{
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download=fileName;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  if(navigator.canShare && navigator.canShare({files:[new File([blob], fileName, {type:'text/csv'})]}) && navigator.share){
    const f = new File([blob], fileName, {type:'text/csv'});
    navigator.share({files:[f], title:'Team Tracker CSV'}).catch(()=>doDownload());
  } else {
    doDownload();
  }
}

/* Debug placeholders */
function updateDebugLines(){}

/* Plus/minus table */
function makePlusMinusTable(){
  const {pm, order} = computePlusMinus();
  if(!order.length) return '<div class="small" style="margin-top:4px;">No plus/minus data.</div>';
  let html = '<table><tr><th>#</th><th>+/-</th></tr>';
  for(const n of order){
    const val = pm.get(n);
    html += `<tr><td>${n}</td><td>${val>0?'+':''}${val}</td></tr>`;
  }
  html += '</table>';
  return html;
}

/* Roster Modal */
function openRoster(){
  const area = $('rosterArea');
  area.value = (state.roster||[]).join('\n');
  $('rosterModal').style.display='flex';
}
function saveRosterFromArea(){
  const raw = $('rosterArea').value.split('\n').map(x=>x.trim()).filter(x=>x.length>0);
  state.roster = sortRoster(raw);
  localStorage.setItem(ROSTER_KEY, JSON.stringify(state.roster));
  save();
  $('rosterModal').style.display='none';
}
function closeRoster(){ $('rosterModal').style.display='none'; }

/* Player picker flow (supports scorer + assist) */
let pickerFlow = {mode:null, pendingGoalEv:null};

function openPicker(mode, label, { showNone=false, exclude=[] } = {}){
  pickerFlow.mode = mode;
  $('pickerTitle').textContent = label || 'Select Player';

  $('pickerNone').style.display = showNone ? 'inline-block' : 'none';

  const excludeSet = new Set((exclude || []).map(x => String(x).trim()).filter(Boolean));

  const roster = sortRoster((state.roster || []).map(x => String(x).trim()).filter(Boolean));
  const uniq = Array.from(new Set(roster)).filter(n => !excludeSet.has(String(n)));

  $('pickerGrid').innerHTML = uniq.length
    ? uniq.map(n=>`<div class="pickerBtn" data-n="${n}">#${n}</div>`).join('')
    : `<div class="small" style="grid-column:1/-1;">No roster yet. Type a number below.</div>`;

  $('pickerInput').value='';
  $('pickerModal').style.display='flex';
}

/* IMPORTANT CHANGE:
   If you tap a roster number, it is immediately applied (no "Use" required). */
$('pickerGrid').addEventListener('click', e=>{
  const b=e.target.closest('.pickerBtn');
  if(!b)return;
  applyPickerSelection(b.dataset.n);
});
$('pickerAdd').addEventListener('click', ()=>{
  const num = $('pickerInput').value.trim() || '?';
  applyPickerSelection(num);
});
$('pickerUnknown').addEventListener('click', ()=>applyPickerSelection('?'));
$('pickerNone').addEventListener('click', ()=>{
  // No Assist
  applyPickerSelection(null);
});
$('pickerCancel').addEventListener('click', ()=>{
  $('pickerModal').style.display='none';
  pickerFlow.mode=null;
});

function applyPickerSelection(num){
  const mode = pickerFlow.mode;
  $('pickerModal').style.display='none';

  if(!mode) return;

  // roster auto-grow for numeric entries (main behavior)
  if(num!==null) ensureRosterNumber(String(num));

  if(mode==='for_shot'){
    addEvent('for_shot',{player: (num===null ? '?' : String(num))});
    pickerFlow.mode=null;
    renderAll();
    return;
  }

  if(mode==='for_goal_scorer'){
    // scorer can be unknown
    const scorer = (num===null ? '?' : String(num));
    ensureRosterNumber(scorer);

    const ev = addEvent('for_goal',{player:scorer});
    pickerFlow.pendingGoalEv = ev;

    // next: assist picker (optional, can be unknown too)
    pickerFlow.mode='for_goal_assist';
    openPicker('for_goal_assist','Assist (optional)',{showNone:true, exclude:[scorer]});
    return;
  }

  if(mode==='for_goal_assist'){
    const ev = pickerFlow.pendingGoalEv;
    if(!ev){ pickerFlow.mode=null; return; }

    // assist can be null (no assist) or unknown '?'
    ev.assist = (num===null ? null : String(num));
    if(ev.assist!==null) ensureRosterNumber(ev.assist);

    save();
    renderAll();

    // now on-ice (other 3, excluding scorer/assist), then strength
    const exclude = [];
    if(ev.player) exclude.push(String(ev.player));
    if(ev.assist) exclude.push(String(ev.assist));
    openMultiPicker({title:'Other 3 On Ice (optional)', max:3, event:ev, field:'forOnIce', exclude});
    pickerFlow.mode=null;
    pickerFlow.pendingGoalEv=null;
    return;
  }

  pickerFlow.mode=null;
}

/* AI calls */
async function runAI(endpoint, payload){
  const res = await fetch(endpoint,{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body:JSON.stringify(payload||{})
  });
  const d = await res.json();
  if(!d || !d.success) throw new Error('AI failed');
  return d;
}
async function aiPracticePlan(){
  $('aiPracticeCard').style.display='block';
  $('aiPracticeBody').textContent = 'Loading…';
  try{
    const d = await runAI('/api/practice-plan', {game: state});
    $('aiPracticeBody').textContent = d.text || d.result || '—';
  }catch(e){
    $('aiPracticeBody').textContent = 'Failed.';
  }
}
async function aiGoalieReport(){
  $('aiGoalieCard').style.display='block';
  $('aiGoalieBody').textContent = 'Loading…';
  try{
    const d = await runAI('/api/goalie-report', {game: state});
    $('aiGoalieBody').textContent = d.text || d.result || '—';
  }catch(e){
    $('aiGoalieBody').textContent = 'Failed.';
  }
}
async function aiSeasonFocus(){
  $('aiFocusCard').style.display='block';
  $('aiFocusBody').textContent = 'Loading…';
  try{
    const d = await runAI('/api/season-focus', {game: state});
    $('aiFocusBody').textContent = d.text || d.result || '—';
  }catch(e){
    $('aiFocusBody').textContent = 'Failed.';
  }
}

/* Init */
(function init(){
  // Version pill
  $('verPill').textContent = `v${APP_VERSION}`;

  // Date input default AND state sync
  const today = new Date();
  $('date').valueAsDate = today;
  state.date = today.toISOString().slice(0,10);

  try{ state.roster = JSON.parse(localStorage.getItem(ROSTER_KEY))||[]; }catch(_){}
  persistStorage();

  // cloud ping (useful status)
  pingCloud();

  load().then(loaded=>{
if(loaded && Array.isArray(loaded.events)){
  Object.assign(state,loaded);
  state.events.sort((a,b)=>new Date(a.tISO)-new Date(b.tISO));
  rebuildFromEvents();

  // Only show the banner if we actually resumed a game with events
  if(state.events.length > 0){
    $('resumeBanner').classList.remove('hidden');
    toggleSetup(false);
  } else {
    $('resumeBanner').classList.add('hidden');
  }
}

    // Ensure date always has a value
    if(!state.date){
      const v = $('date').value;
      if(v) state.date = v;
    } else {
      $('date').value = state.date;
    }

    $('opponent').value = state.opponent || '';
    $('level').value = state.level || $('level').value;

    updateMeta();
    highlightPeriod();
    if(state.events.length>0) renderAll();
    refreshCloudStatus();

    // If not saved, show cloud OK/offline (don’t leave it stuck on "—")
    const last = localStorage.getItem(LAST_SAVED_KEY);
    if(!last || last !== state.gameId){
      pingCloud();
    }
  });
})();

function renderAll(){
  rebuildFromEvents();
  updateMeta();
  renderLog();
}

/* Button Wiring */
$('btnRoster').onclick=openRoster;
$('btnRosterSave').onclick=saveRosterFromArea;
$('btnRosterClose').onclick=closeRoster;

$('btnShot').onclick=()=>addEvent('shot');
$('btnGoal').onclick=()=>addEvent('goal');

$('btnForShot').onclick=()=>openPicker('for_shot','Shooter');
$('btnForGoal').onclick=()=>openPicker('for_goal_scorer','Scorer');

$('btnSoftGoal').onclick=()=>addEvent('soft_goal');
$('btnBadRebound').onclick=()=>addEvent('bad_rebound');

$('btnBreakaway').onclick=()=>addEvent('breakaway_against');
$('btnDZTurnover').onclick=()=>addEvent('dz_turnover');

$('btnSmother').onclick=()=>addEvent('smother');
$('btnBigSave').onclick=()=>addEvent('big_save');

/* Offensive context */
$('btnBreakawayFor').onclick=()=>{
  lastBreakawayForTap = Date.now();
  addEvent('breakaway_for');
};
$('btnOddManRushFor').onclick=()=>addEvent('odd_man_rush_for');

$('periodChips').addEventListener('click',e=>{
  const c=e.target.closest('.p-opt');
  if(!c)return;
  state.period=Number(c.dataset.p);
  save();
  highlightPeriod();
});

$('btnNextPeriod').onclick=()=>{
  state.period=Math.min(4,state.period+1);
  save();
  highlightPeriod();
  vibrate(20);
};

$('btnEnd').onclick=endGame;

$('btnReset').onclick=()=>{
  if(!confirm('Clear game?'))return;

  // Hide "Resumed saved game" banner when starting a truly new game
  $('resumeBanner').classList.add('hidden');

  state.events=[];
  state.opponent='';
  $('opponent').value = '';
  state.countsA={shots:0,goals:0,softGoals:0,smothers:0,badRebounds:0,bigSaves:0};
  state.countsF={shots:0,goals:0};
  state.team={breakawaysAgainst:0,dzTurnovers:0,breakawaysFor:0,oddManRushFor:0};
  per={1:initP(),2:initP(),3:initP(),4:initP()};

  state.gameId = Math.random().toString(36).slice(2);
  state.startedAt = new Date().toISOString();
  state.lastEventId = 0;

  save();
  toggleSetup(true);
  renderAll();
  $('summaryPanel').classList.add('hidden');

  // reset cloud pill to connectivity
  try{ localStorage.removeItem(LAST_SAVED_KEY); }catch(_){}
  pingCloud();
};

/* Modals close on backdrop click */
document.querySelectorAll('.modal').forEach(m=>
  m.addEventListener('click',e=>{if(e.target===m)m.style.display='none';})
);

/* Inputs */
$('opponent').oninput=e=>{state.opponent=e.target.value;save();}
$('level').onchange=e=>{state.level=e.target.value;save();}
$('date').onchange=e=>{state.date=e.target.value;save();}

/* Copy Summary (now: compact, structured text) */
$('btnCopySummary').addEventListener('click', ()=>{
  const date = state.date || new Date().toISOString().slice(0,10);
  const SF=state.countsF.shots, SA=state.countsA.shots, GF=state.countsF.goals, GA=state.countsA.goals;
  const saves=Math.max(0,SA-GA);
  const svText = SA ? (saves/SA).toFixed(3).slice(1) : '—';
  const shootPct = SF ? (GF/SF).toFixed(3).slice(1) : '—';
  const share = (SF+SA) ? Math.round(100*(SF/(SF+SA)))+'%' : '—';
  const K=computeGoalieScore(), T=computeTeamScore();
  const gfCtx = computeGFContextBreakdown();
  const gaStats = computeGABreakdown();

  const lines = [
    `${state.level||'?'} vs ${state.opponent||'Unknown'} on ${date}`,
    `Score: Us ${GF} – ${GA} Them`,
    `Shots: SF ${SF}, SA ${SA} | Saves ${saves} | SV% ${svText}`,
    `Team Score: ${T.total}/100 | Goalie Score: ${K.total}/100`,
    `Smothers ${state.countsA.smothers} | Bad Reb ${state.countsA.badRebounds} | Big Saves ${state.countsA.bigSaves} | Soft Goals ${state.countsA.softGoals}`,
    `Shot Share ${share} | Our Shooting% ${shootPct}`,
    `BA Ag ${state.team.breakawaysAgainst} | DZ TO ${state.team.dzTurnovers} | BA For ${state.team.breakawaysFor} | OMR For ${state.team.oddManRushFor}`,
    `GF off BA ${gfCtx.BA} | GF off OMR ${gfCtx.OMR} | GF Other ${gfCtx.Other}`,
    `GA off Bad Reb ${gaStats.BR} | GA off BA ${gaStats.BA} | GA off DZ ${gaStats.DZ} | GA Other ${gaStats.Other}`

  ];

  const text = lines.join('\n');
  $('copyArea').value = text;
  $('copyModal').style.display='flex';
  if(navigator.clipboard && text){
    navigator.clipboard.writeText(text).catch(()=>{});
  }
});
$('btnCopySelect').addEventListener('click', ()=>{
  const area = $('copyArea');
  area.focus();
  area.select();
});
$('btnCopyClose').addEventListener('click', ()=>{ $('copyModal').style.display='none'; });

/* Export CSV */
$('btnExportGameCSV').addEventListener('click', exportGameCSV);

/* AI / Season buttons */
$('btnAIPractice').addEventListener('click', aiPracticePlan);
$('btnAIGoalieReport').addEventListener('click', aiGoalieReport);
$('btnAIFocus').addEventListener('click', aiSeasonFocus);

</script>
</body>
</html>
